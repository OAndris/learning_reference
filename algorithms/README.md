# algorithms

## Algorithm complexity:

- **Space complexity:** How much memory (storage space) does the algorithm need to do what it does?
- **Time complexity:** How much time does the algorithm take to complete, relative to the size of its input?

## Understanding algorithm performance:

- Measure how an algorithm responds to dataset size
- Big-O notation

## Big-O notation:

- Classifies performance as the input size grows
- "O" indicates the *order of operation*: time scale to perform an operation
- Many algorithms and data structures have more than one Big-O value (separate values for inserting data, searching for data, deleting data, etc.)
- Common Big-O notations:
    - O(1)       -> constant time (e.g. looking up a single element in an array)
    - O(log n)   -> logarithmic (e.g. finding an item in a sorted array with a binary search)
    - O(n)       -> linear time (e.g. searching an unsorted array for a specific value)
    - O(n*log n) -> log-linear (e.g. complex sorting algorithms like heap sort and merge sort)
    - O(n^2)     -> quadratic (e.g. simple sorting algorithms, such as bubble sort, selection sort, and insertion sort)

## Inputs and outputs:

What inputs does the algorithm take and what output values does it return?

## Classification:

- Serial / Parallel
- Exact / Approximate
- Deterministic / Non-deterministic

## Common algorithms:

- **Search algorithms.** Find specific data in a structure
- **Sorting algorithms.** Take a dataset and apply a sort order to it
- **Computational algorithms.** Given one set of data, calculate another (e.g. check if a given number is prime)
- **Collection algorithms.** Work with collections of data (count specific items, navigate among data elements, filter out unwanted data, etc.)

## Source / further info:
- https://www.linkedin.com/learning/programming-foundations-algorithms
