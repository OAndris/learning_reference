# Object-Relational Mapping (ORM) in Python

## Basics:

An Object-Relational Mapper (ORM) helps by abstracting away the details of the database. It interacts with the database driver, from the application code.

Since data is structured differently in an object-oriented programming language than in a relational database, specific code is required for translating from one schema to the other. ORM libraries are responsible for this translation between objects (application) and tables (relational database):
- classes correspond to tables (including a mapping for relationships between classes and relationships between tables)
- instances of classes correspond to rows (records) of tables
- properties of classes correspond to columns (fields) of tables (data types, of course, also have to be mapped)

Using an ORM, developers can focus more on business logic, and also write application code instead of SQL (since the underlying SQL will be generated by the ORM).

ORMs, however, are not database connectors themselves. Instead, they interact with database connectors.

---

**Database connectors:**

For simply accessing relational databases from the application code, an ORM library is not actually required. The low-level access is typically provided by another library, called a database connector / driver. The driver is what actually integrates with a database (and thus, it should adhere to the DBAPI specification).

Examples for Python:
- psycopg (for PostgreSQL)
- mysql-python or pymysql (for MySQL)
- Python standard library built-in connector for SQLite
- etc.

(More examples: https://wiki.python.org/moin/MySQL)

**ORM solutions for Python:**
- SQLAlchemy (standalone library, works with various database connectors, and can be used either with the Flask web framework, or without a web framework)
- Django ORM (built-in solution of the Django web framework)
- etc.

## Benefits and downsides:

There are both benefits and downsides to using an ORM solution instead of direct SQL queries and stored procedures.

Some people argue against using ORMs, e.g. Ted Neward argued that an ORM "represents a quagmire which starts well, gets more complicated as time passes, and before long entraps its users in a commitment that has no clear demarcation point, no clear win conditions, and no clear exit strategy."

Typically, ORMs make it easier and faster to start a project, and work well for easy, medium, not that complicated use cases, perhaps for 80-90% of the use cases in a typical project.

**Benefits:**
- **High-level abstraction** upon a relational database, that allows writing Python code instead of SQL (to create, read, update and delete data and schemas)
- **Easier portability** among different database engines, provided by a database-agnostic, standard interface (at least theoretically, with zero or only minimal code modifications)
- **Easier and faster for starting** a project (although it can prove to be a shaky foundation for extremely complicated database-backed applications)

**Downsides:**
- **Impedance mismatch** (difficulties that occur when moving data between relational tables and application objects)
- **Potential for reduced performance** (when application code is translated to SQL statements, it might not be tuned properly - ORMs are often easy to try but difficult to master)
- **Shifting complexity** from the database into the application code (instead of stored procedures, data manipulation code lives within the application's codebase, further increasing it)


## Core concepts:

- **Engine:**
    - Engines are used to interact with a database
    - An engine can and should be created, for communiting with a database
- **Dialects:**
    - Most of the popular relational databases adhere to the SQL (Structured Query Language) standard, but they also introduce proprietary variations
    - These variations are the solely responsible for the existence of dialects
    - Example: `SELECT TOP 10 * FROM people;` (Microsoft SQL Server) vs. `SELECT * FROM people LIMIT 10;` (MySQL)
    - To know precisely what query to issue, an ORM needs to be aware of the type of the database that it is dealing with. This is exactly what dialects do
    - SQLAlchemy, for example, includes dialects for MySQL, PostgreSQL, Microsoft SQL Server, SQLite, Oracle, Firebird, Sybase
- **Relationships:**
    - **One To Many**
        - an instance of a class can be associated with many instances of another class
        - e.g. on a blog engine, an instance of the Article class could be associated with many instances of the Comment class
    - **Many to One**
        - many instances of a class can be associated with a single instance of another class (same as "One to Many", but from the other perspective)
        - e.g. many tires can belong to one car
    - **One to One**
        - an instance of a class may only be associated with one instance of another class, and vica versa
        - e.g. one person possesses one mobile phone and this mobile phone belongs to this person only
    - **Many to Many**
        - instances of a particular class can have zero or more associations to instances of another class
        - e.g. many students can participate in many classes
- **Cascade:**
    - Whenever operations (e.g. update or delete) are performed on parent objects, child objects might also need to suffer changes (e.g. be updated or deleted)
    - This "cascading" behavior is supported by both databases and ORM solutions (cascade update, cascade delete)
- **Sessions:**
    - Sessions are the implementation of the Unit of Work design pattern
    - All modifications tracked by Sessions will be applied to the underlying database together, or none of them will
    - They guarantee the consistency of the database

## Sources:
- https://www.fullstackpython.com/object-relational-mappers-orms.html
- https://auth0.com/blog/sqlalchemy-orm-tutorial-for-python-developers/
- [Official list of database interfaces for Python](https://wiki.python.org/moin/DatabaseInterfaces)
- [Official SQLAlchemy Relationships API documentation](https://docs.sqlalchemy.org/en/14/orm/relationship_api.html)
